From 12fa5e7188e117594121bb960991dc78a7bc8e82 Mon Sep 17 00:00:00 2001
From: Nikolai Nechaev <nikolay_nechaev@mail.ru>
Date: Sat, 28 Dec 2024 23:01:32 +0300
Subject: [PATCH 4/4] Implement fugitive notifications

Right-clicking notifications will now cause them to jump to the
opposite side of the screen (left and right).

The patch also contains a commented out implementation of the behavior
when they jump away from the cursor when it hovers them, without the
need to click.
---
 .../window/notifications_manager_default.cpp  | 47 ++++++++++++++++---
 .../window/notifications_manager_default.h    |  7 +++
 2 files changed, 47 insertions(+), 7 deletions(-)

diff --git a/Telegram/SourceFiles/window/notifications_manager_default.cpp b/Telegram/SourceFiles/window/notifications_manager_default.cpp
index cb9c10b..51e949b 100644
--- a/Telegram/SourceFiles/window/notifications_manager_default.cpp
+++ b/Telegram/SourceFiles/window/notifications_manager_default.cpp
@@ -43,18 +43,19 @@ https://github.com/telegramdesktop/tdesktop/blob/master/LEGAL
 #include <QtGui/QGuiApplication>
 #include <QtGui/QScreen>
 
+#include <QThread>
+
 namespace Window {
 namespace Notifications {
 namespace Default {
-namespace {
 
-[[nodiscard]] QPoint notificationStartPosition() {
+[[nodiscard]] QPoint Manager::notificationStartPosition() const {
 	const auto corner = Core::App().settings().notificationsCorner();
 	const auto window = Core::App().activePrimaryWindow();
 	const auto r = window
 		? window->widget()->desktopRect()
 		: QGuiApplication::primaryScreen()->availableGeometry();
-	const auto isLeft = Core::Settings::IsLeftCorner(corner);
+	const auto isLeft = _isLeft;
 	const auto isTop = Core::Settings::IsTopCorner(corner);
 	const auto x = (isLeft == rtl())
 		? (r.x() + r.width() - st::notifyWidth - st::notifyDeltaX)
@@ -68,14 +69,13 @@ internal::Widget::Direction notificationShiftDirection() {
 	return isTop ? internal::Widget::Direction::Down : internal::Widget::Direction::Up;
 }
 
-} // namespace
-
 std::unique_ptr<Manager> Create(System *system) {
 	return std::make_unique<Manager>(system);
 }
 
 Manager::Manager(System *system)
 : Notifications::Manager(system)
+, _isLeft(Core::Settings::IsLeftCorner(Core::App().settings().notificationsCorner()))
 , _inputCheckTimer([=] { checkLastInput(); }) {
 	system->settingsChanged(
 	) | rpl::start_with_next([=](ChangeType change) {
@@ -467,6 +467,11 @@ Manager::~Manager() {
 	clearAllFast();
 }
 
+void Manager::flipNotificationSide() {
+	_isLeft = !_isLeft;
+	settingsChanged(ChangeType::Corner);
+}
+
 namespace internal {
 
 Widget::Widget(
@@ -543,7 +548,23 @@ void Widget::hideStop() {
 	if (_hiding) {
 		_hiding = false;
 		_hidingDelayed = {};
-		_a_opacity.start([this] { opacityAnimationCallback(); }, 0., 1., st::notifyFastAnim);
+		/*
+		 * `Notification::isShowing()` does not distinguish between kinds of animations,
+		 * so it errornously considers its state of fading in as fading out, preventing
+		 * the manager from fading it out when it should.
+		 *
+		 * To fix that, we block `Widget::hideStop` until the animation is complete.
+		 *
+		 * Note: I've shortened the animation period from `st::notifyFastAnim` to 1 millisecond.
+		 * This is probably not necessary, and might work okay even with the default delay. But
+		 * if you try that, you will have to also increase the sleep in `QThread::msleep` to
+		 * `st::notifyFastAnim`, and in this case I'd suggest that you move the call to
+		 * `QThread::msleep` from this method to `Manager::stopAllHiding` so that it only
+		 * sleeps once rather than once per notification.
+		 */
+		//_a_opacity.start([this] { opacityAnimationCallback(); }, 0., 1., st::notifyFastAnim);
+		_a_opacity.start([this] { opacityAnimationCallback(); }, 0., 1., 1/*millisecond*/);
+		QThread::msleep(1);
 	}
 }
 
@@ -637,6 +658,8 @@ Notification::Notification(
 , _fromScheduled(fromScheduled)
 , _close(this, st::notifyClose)
 , _reply(this, tr::lng_notification_reply(), st::defaultBoxButton) {
+	//setMouseTracking(true);
+
 	Lang::Updated(
 	) | rpl::start_with_next([=] {
 		refreshLang();
@@ -1191,11 +1214,21 @@ void Notification::startHiding() {
 	hideSlow();
 }
 
+/*
+void Notification::mouseMoveEvent(QMouseEvent *e) {
+	e->ignore();
+	if (!(e->modifiers() & Qt::ControlModifier)) {
+		manager()->flipNotificationSide();
+	}
+}
+*/
+
 void Notification::mousePressEvent(QMouseEvent *e) {
 	if (!_history) return;
 
 	if (e->button() == Qt::RightButton) {
-		unlinkHistoryInManager();
+		//unlinkHistoryInManager();
+		manager()->flipNotificationSide();
 	} else {
 		e->ignore();
 		manager()->notificationActivated(myId());
diff --git a/Telegram/SourceFiles/window/notifications_manager_default.h b/Telegram/SourceFiles/window/notifications_manager_default.h
index 5bd4344..e6d652a 100644
--- a/Telegram/SourceFiles/window/notifications_manager_default.h
+++ b/Telegram/SourceFiles/window/notifications_manager_default.h
@@ -45,6 +45,10 @@ public:
 		return ManagerType::Default;
 	}
 
+	[[nodiscard]] QPoint notificationStartPosition() const;
+
+	void flipNotificationSide();
+
 	template <typename Method>
 	void enumerateNotifications(Method method) {
 		for (const auto &notification : _notifications) {
@@ -96,6 +100,8 @@ private:
 
 	void subscribeToSession(not_null<Main::Session*> session);
 
+	bool _isLeft;
+
 	std::vector<std::unique_ptr<Notification>> _notifications;
 	base::flat_map<
 		not_null<Main::Session*>,
@@ -241,6 +247,7 @@ protected:
 	void enterEventHook(QEnterEvent *e) override;
 	void leaveEventHook(QEvent *e) override;
 	void paintEvent(QPaintEvent *e) override;
+	//void mouseMoveEvent(QMouseEvent *e) override;
 	void mousePressEvent(QMouseEvent *e) override;
 	bool eventFilter(QObject *o, QEvent *e) override;
 
-- 
2.47.1

